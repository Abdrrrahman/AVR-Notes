# Why make and cmake?
To learn what is make and cmake, we need to get back a few years, One day in late 70s a man working on a project, He was trying to fix a bug that he discovered, He entered the office to his friend so furious that a problem occurred when he was compiling his project made him re-compile the whole process again. His friend thought of a thing that can automate this process.
## But is compiling that hard?
As we talked about modularity earlier, We can have in the same project near 100, 1000 or more source files. To compile all them into one and only one program, we need to type them in one command like this:
```bash
gcc file_1.c file_2.c file_3.c   .............................  file_1000.c
```
This is inconvenient, no one can really do that, and even if you changed only 1 source file, you will need to compile the whole 1000 file again when you can only compile 1 that file only.
# What is make and cmake?
**Make** is the traditional build system that has been used with C for decades. It reads Makefiles that specify how to compile and link C source files. Make is particularly well-suited for C because:
- It was originally designed alongside C development
- Most C compilers (gcc, clang, etc.) work seamlessly with make
- Simple C projects can use very straightforward Makefiles

**CMake** is a more modern build system generator that's also excellent for C projects. It generates native build files (including Makefiles) for your platform. CMake offers several advantages for C development:
- Cross-platform support (Windows, Linux, macOS)
- Better dependency management
- More readable syntax than traditional Makefiles
- Excellent integration with IDEs
- Built-in support for finding C libraries and headers

For a simple C project, you might use make directly with a basic Makefile. For more complex C projects, especially those that need to work across different platforms or have complex dependencies, CMake is often the better choice.

Both tools understand C compilation requirements like header dependencies, object file generation, and linking, making them natural fits for C development workflows
# What is the makefile?
You can use `make` to manage and automate building or running **any application**.
`make` relies on a file called **Makefile**, which defines rules and instructions.

Example:
Adding `echo` in the first line of a Makefile will immediately print text when running `make`.
You can add commands like `cp` (copy) or `rm` (remove).
```make
hello:
	echo "Hello World"
```
Output in terminal:
```
echo "Hello World"
Hello World
```

You can set the command to a silent one by putting a `@` before it.
```make
hello:
	@echo "Hello World"
```
Output in terminal:
```
Hello World
```

So, The basic syntax of a makefile is like this:
```make
target: dependencies
    command1
    @command2
```
Target→ the file/task to build (e.g., an app, object file).
Dependencies → files needed before building.
Commands → shell commands executed (must start with a **TAB**).
## Example:
```make
.PHONY: all echo clean

all: echo app

echo:
	@echo "Compiling all files ..."

app: main max min
	@gcc main.o max.o min.o -o app

main:
	@gcc -c main.c

max:
	@gcc -c max.c

min:
	@gcc -c min.c

clean:
	@rm -f *.o app
```

```make
all: echo app
```
The **default target** is `all` (executed when you just type `make`).
It depends on two dependencies:
`echo` → Just printing a message.
`app` → building the whole program.

```make
app: main max min
	@gcc main.o max.o min.o -o app
```
Linking all the object files into one executable named as `app`.

```make
main: main.c
    @gcc -c main.c

max:
	@gcc -c max.c
	
min:
	@gcc -c min.c
```
Compiling each source file of them.

```make
clean:
	@rm -f *.o app
```
`rm` → Linux/Unix command to remove (delete) files.
`-f` → "force": don’t ask for confirmation and don’t complain if the file doesn’t exist.
`*.o` → wildcard that matches **all object files** (`main.o`, `max.o`, `min.o`, etc).
`app`** → the compiled executable program.
So, when we type in the shell program `make clean` it deletes all the object files and the executable `app`.

```make
.PHONY: all echo clean
```
This is telling Make that the targets all, echo, and clean are phony targets.
### What is a phony target?
Normally, in a Makefile, a target is tied to a file.
For example:
`main.o: main.c`
Here, main.o is a file that will be created.
Make checks if main.o already exists and whether it’s newer than main.c before running the rule.

But targets like all, echo, and clean are not files, they are just labels for actions.
If you didn’t declare them as .PHONY, then:
If you had a file named clean in your folder, `make clean` would do nothing (because Make would think "clean already exists and doesn’t need rebuilding").
Same with all or echo.
****
