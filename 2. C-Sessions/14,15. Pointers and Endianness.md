#pointers
# Pointers:
Pointers are drift datatype, they are variables that are able to store the address of other variables. It takes the same datatype of the variable storing its address.
The size of pointers is determined by the number of address lines on the micro-controller or the processor. 
The Address lines of normal processors are 16-bit, 32-bit or 64-bit according to the archi of the system and the compiler. But in this article we will continue with 32-bit.
If we declare a variable x of integer datatype, it will take 4 bytes in the memory, each byte having 32 bits. If we tried to access the address of the x variable we will only access the address of the first byte.
![pic1_14](pic1_14.png)
To declare a pointer we follow this:
`[Datatype_of_variable_to_be_pointed]* [pointer_name]`, so it be like this:
`int* ptr;`
If we declared a char pointer and integer pointer, you will notice that the size of both is constant **4 bytes in our case.**
```c
#include <stdio.h>

int main(void) {
	int* int_ptr;
	char* char_ptr;
	
	printf("%i\n", sizeof(int_ptr));
	printf("%i", sizeof(char_ptr));
}
```
Output on 32-bit system:
```
4
4
```
Output on 64-bit system:
```
8
8
```
**Why is that?**
The pointers hold the address of the first byte of the variable assigned to them, so it must hold 32 bits (4 bytes) on 32-bit system, or 64 bits (8 bytes) on 64-bit system, or 16 bits (2 bytes) on atmega32.
Note: The pointers are variables, so they also have addresses.
## Assigning Addresses:
We can assign addresses inside pointer through two ways:
```c
// Way 1
int* ptr_1 = &x;

// Way 2
int* ptr_2;
ptr_2 = &x; // can not have astrisk here
```
Notice that:
```c
char* y,z;
// here only y is a pointer, while z is a normal char variable. 

char* y,*z;
// here both are pointers.
```
Best Practice it to stick the asterisk to the pointer's name.
## Accessing Pointers:
We can access the pointer through its dereference operator.
```c
int x = 50;
int *ptr = &x;
*ptr = 120;
```
As the pointer is the same datatype of the variable pointed to, it will access the first byte and continues the rest 3 bytes.

What if the pointer was not the same datatype of the variable?
```c
int x = 50;
short *ptr = &x;
*ptr = 120;
```
What happens here is that the pointer is accessing only the first two bytes of the x variable, which makes a lot of troubles. So this gives a compilation error.
```
error: incompatible pointer type 
```

The Asterisk has 3 names during the accessing:
- Dereference operator: As it cancels out the referencing.
- Value of operator: As it gives out the value of what is the pointer is holding
- Indirection operator: As we access the variables indirectly through it
The dereference asterisk is considered a unary operator.

So keep that in notice:
![pic3_14](pic3_14.png)
## Pointers step:
Each pointer has a step of n bytes. If the pointer is int then it's step is 4 bytes, if it is char then its one byte.
So, When we increment a pointer we are incrementing it by a step.
```c
int x = 50;
int *p = &x;
p++; // Now the pointer is shifted 4 bytes.
```
# Pointers Casting
Pointer casting is the process of converting a pointer from one type to another. It's a powerful but potentially dangerous feature that requires careful handling.
### Implicit Casting (Automatic):
```c
void* generic_ptr;
int* int_ptr;
generic_ptr = int_ptr;  // Implicit cast to void* - always safe
```
### Explicit Casting (Manual):
```c
void* generic_ptr;
int* int_ptr = (int*)generic_ptr;  // Explicit cast from void*
```

If you try to deal with a short pointer to an int value, you will notice that the compiler will give you a warning, or even in some compilers like in VScode it refuses and gives an error. In Cpp it also refuses on most compilers.
```c
int x=1090;
short *p=&x;
```
Output on VScode:
```
error: initialization of 'short int *' from incompatible pointer type 'int *'
```
What happens here is that it deals with `&x` as an integer pointer value, so it needs to be casted into short:
```c
int x=1090;
short *p=(short*)&x
```
This works well, telling the compiler that I know what I am doing, it is not by accident.
# Some Examples on pointers:
## Example 1:
If you see this code snippet:
```c
#include <stdio.h>

int main() {
	int number=258;
	char *ptr=&number;
	printf("%i\n", *ptr++); // 2
	printf("%i\n", *ptr);   // 1
}
```
What happens is that the ptr is of 1 byte size, so it points to the first byte of the 4 bytes of number which is `0000 0010` then it is incremented by one step (1 byte) which means that it will point to the next byte which is `0000 0001`.
![pic2_14.png](pic2_14.png)
## Example 2:
If you look at this code snippet:
```c
#include <stdio.h>

int main() {
    int x = 258;
    int *ptr1 = &x;
    char *ptr2 = &x;
    printf("%i\n", *ptr1); // -> 258
    printf("%i\n", *ptr2); // -> 2
    *ptr2 = 4;
    printf("%i\n", *ptr1); // -> 260
    printf("%i\n", *ptr2); // -> 4
    return 0;
}
```
You will notice that the `*ptr2=4;`statement changes the whole byte of the variable x. Which also overwrites the value of the first byte from `0000 0010` into `0000 0100`.

## Alternative way on Modern IDEs:
Those 2 Examples work fine on codeblocks as it uses an older version of gcc while VScode and modern IDEs use more strict compilers that won't compile this code.
In nowadays compilers do not support assigning non-convenient pointer types, but we can achieve that by an alternative way.
This alternative way is explicit casting of the pointers:
instead of `char *ptr2 = &x;` we can type this `int *ptr2 = (char*)&x;`
Full code:
```c
#include <stdio.h>

int main() {
    int x = 258;
    int *ptr1 = &x;
    char *ptr2 = (char*)&x;
    printf("%i\n", *ptr1); // -> 258
    printf("%i\n", *ptr2); // -> 2
    *ptr2 = 4;
    printf("%i\n", *ptr1); // -> 260
    printf("%i\n", *ptr2); // -> 4
    return 0;
}
```
## Example 3:
If you notice this code:
```c
#include <stdio.h>

int main() {
    int x;
    int *ptr;
    printf("%i\n", &x);
    printf("%i\n", &ptr);
    return 0;
}
```
Output:
```
6356728
6356732
```
You will notice that they are after each other as they are ordered in the stack.
## Example 4:
Using fake pointers, you can use fake pointers but they will have some incompatibility problems:
```c
#include <stdio.h>

int main() {
    int x;
    int *realPTR=&x;
    int fakePTR=(int)&x;
    printf("%llx\n", &x); 
    printf("%llx\n", realPTR);
    printf("%llx\n", fakePTR);
    return 0;
}
```
Output:
```
f3d63ff8b0
f3d63ff8b0
d63ff8b0
```
We are using `"%llx"` as pointers are preferred with addresses or `"%p"`. The `"%llx"` expects a 64-bit address "unsigned long long" and the `"%p"` suits the pointer address according to the system. 
While using `"%x"` expects a 32-bit address "unsigned int" which makes it truncates the address.
```c
#include <stdio.h>

int main() {
    int x;
    int *realPTR=&x;
    int fakePTR=(int)&x;
    printf("%x\n", &x); 
    printf("%x\n", realPTR);
    printf("%x\n", fakePTR);
    return 0;
}
```
Output:
```
32bffbe0  // truncated (not the full address)
32bffbe0  // truncated (not the full address)
32bffbe0  // full address
```
## Example 5:
When you subtract one pointer from another, the compiler first subtracts their memory addresses, then divides the result by the size of the data type they point to. This way, the result represents how many elements (or steps) apart the two pointers are.
```c
#include <stdio.h>

int main() {
    int *p1 = (void*) 100, *p2 = (void*) 200;
    int steps = p2-p1;
    printf("%i\n", steps);
    return 0;
}
```
Output:
```
25 
// 200-100/4
```
`(void*)` is a **type cast** in C and C++ that converts a value or pointer to a "void pointer" type.
If you try to add them it will give you a syntax error, as adding has no meaning.
```c
int steps = p2+p1; // syntax error
```
## Example 6:
Make sure that your pointer matches what it is pointing to.
```c
#include <stdio.h>

int main () {
	unsigned short x = 65535;
	short *p = &x;
	
	if(65535==*p)
		printf("They are Equal\n");
	else
		printf("They are different\n");
}
```
Output:
```
They are different
```
As you can see here the x is unsigned short while the pointer is signed so, when comparing the pointer is of a value of `11111111 11111111` which is considered `-1` in signed short type.
But if we casted it into unsigned short:
```c
#include <stdio.h>

int main () {
  unsigned short x = 65535;
  short *p = &x;
  if(65535==(unsigned short)*p)
    printf("They are Equal\n");
  else
    printf("They are different\n");
}
```
Output:
```
They are Equal
```
## Example 7:
```c
#include <stdio.h>

int main () {
    unsigned int  var = 20;
    unsigned int  *ip;
    ip = &var;
    
    printf("%p\n", &var);
    printf("%p\n\n", ip);
    printf("%u\n", *&var);
    printf("%u\n", *ip );
    
    return 0;
}
```
Output:
```
00000080eabffa44
00000080eabffa44

20
20
```
As the compiler translates the `&var` to an `unsigned int *p` carrying the address of the var, it translates into dereferencing a pointer.
`*&var` = `*(unsigned int pointer carrying the address of var)`.

# Subscriptor Operator
Imagine that you have a 4-byte integer and you try to access the bytes number 3 and 4 (second 2 bytes) in it through a short pointer.
```c
#include <stdio.h>

int main() {
    int x=65538;
    short *p=(short*)&x;
    printf("%i\n",*(p+1)); // Accesses second two bytes
    printf("%i\n",*p);     // Accesses first two bytes
    return 0;
}
```
Another approach for doing that is by the subscriptor operator:
```c
#include <stdio.h>

int main() {
    int x=65538;
    short *p=(short*)&x;
    printf("%i\n",p[1];      // Equivalent to *(p+1)
    printf("%i\n",p[0]);     // Equivalent to *p
    return 0;
}
```

# Incrementing Pointers
## Example 1:
```c
#include <stdio.h> 
#include <stdlib.h> 
int main() { 
	int x=50, y; 
	int* ptr=&x; 
	printf("%i\n", ptr); 
	y=*ptr++; 
	printf("%i\n", x); 
	printf("%i\n", y); 
	printf("%i\n", ptr); 
	return 0; 
}
```
Output:
```
1545599536
50
50
1545599540
```
You will notice here that the incrementing operator `++` has a higher precedence than the dereference operator `*`.
So, first it post increments the `ptr` then it dereferences it.
## Example 2:
```c
#include <stdio.h> 
#include <stdlib.h> 
int main() { 
	int x=50, y; 
	int* ptr=&x; 
	printf("%i\n", ptr); 
	y=(*ptr)++; 
	printf("%i\n", x); 
	printf("%i\n", y); 
	printf("%i\n", ptr); 
	return 0; 
}
```
Output:
```
1545599536
51
50
1545599540
```
The braces here have a higher precedence than the incrementing operator, which means that the braces first executes (dereferencing) then the rest of the line (incrementing).
# Pointers with constants
If you can see this code
```c
#include <stdio.h>

int main() {
    const int x=5;
    int *ptr=(int*)&x;
    *ptr=20;
    printf("%i\n", x);
}
```
Output:
```
20
```
We can modify the const values in C using pointers, but how is that?
The const local variables are stored in the stack, so we can access them by working around the compiler and changing them through pointers.
****
But if we have a const global variable that is initialized with a non zero value and we are trying to access it through pointers, That is not valid even though it will compile normally.
```c
#include <stdio.h>

const int y=12;

int main() {
    int *p2=(int*)&y;
    *p2=20;
    printf("%i\n", y);
}
```
This happens due to trying to access the `.rodata` memory segment which is read only. Trying to read inside the `.rodata` will crash the problem causing a runtime error.
```cpp
#include <iostream>

int main () {
    const int x = 5;
    int *p=(int*)&x;
    *p=20;
    std::cout << x << std::endl;
    std::cout << ++*p << std::endl;
}
```
****
But if you try to do this with a const global uninitialized or initialized with zero, The const global variable will be stored in the `.bss` segment which means that we can write in it.
So, in some compilers you will see this code works fine:
```c
#include <stdio.h>

const int x;
int main()
{
    int* ptr=(int*)&x;
    printf("ok\n");
    *ptr=100;
    printf("not ok\n");
    printf("x=%i\n",x);
    return 0;
}
```
Output on Codeblocks:
```
ok
not ok
x=100
```
****
This C++ code demonstrates undefined behavior! Here's what it's doing:
1. **`const int x = 5;`** - Declares a constant integer with value 5
2. **`int *p = (int*)&x;`** - Creates a non-const pointer to the const variable (using a C-style cast to override the const qualifier)
3. **`*p = 20;`** - Attempts to modify the const variable through the pointer
4. **Prints both `x` and `*p`**
**Important notes:**
- This code exhibits **undefined behavior** because you're modifying a `const` variable
- The compiler might optimize based on the assumption that `x` never changes
- Results are unpredictable - `x` might still show 5 while `*p` shows 20, or both might show 20, or anything could happen
- Different compilers and optimization levels will produce different results
```cpp
#include <iostream>

int main () {
    const int x = 5;
    int *p=(int*)&x;
    *p=20;
    std::cout << x << std::endl;
    std::cout << ++*p << std::endl;
}
```
# Wild Pointers
They are uninitialized or dangling pointers are pointers that point to arbitrary memory locations. They're one of the most dangerous types of bugs because they can cause unpredictable program behavior.
**Uninitialized pointers**:
Pointers declared but not assigned a valid memory address. They contain whatever garbage value was in that memory location.
```c
int *ptr;  // Wild pointer - contains random memory address
*ptr = 5;  // Undefined behavior - writing to unknown memory
```
**Dangling pointers**: 
Pointers that once pointed to valid memory, but that memory has been freed or deallocated.
```c
int *ptr = malloc(sizeof(int));
free(ptr);
*ptr = 5;  // Wild pointer - accessing freed memory
```
**Out-of-scope pointers**: 
Pointers to local variables that have gone out of scope.
```c
int* getPointer() {
    int x = 10;
    return &x;  // Returns pointer to local variable
}
// The returned pointer becomes wild when x goes out of scope
```

Trying to access (writing/reading) wild pointers will result in runtime error named as *segmentation fault*, As the pointer can be pointing to a value that is incompatible with the pointer datatype. 
So, in some compilers you can't assign an address manually to a pointer as you don't know that address is as the same datatype as your pointer or not.
****
***Segmentation Fault*:**
It is a runtime error occurs when you encounter to write or read an illegal memory location.
****
# Null Pointers
## Null character:
Null is the first character found in ASCI table, representing it in double quotes is `'\0'`, its binary is `0000 0000` representing `0`.
If you tried to print null character it will print nothing:
```c
#inlude <stdio.h>

int main() {
	printf("OK");
	printf("%i", '\0');
	printf("OK");
}
```
Output:
```
OKOK
```
It is used to indicate the end of a specific string.
## Null pointer:
It is a pointer that is pointing to NULL. You can not dereference it. Dereferencing it results in runtime error.
### Declaring a Null pointer has too many ways in C:
#### 1. Using NULL macro (most common)
```c
int *ptr = NULL;
char *str = NULL;
void *generic = NULL;
```
#### 2. Using literal 0
```c
int *ptr = 0;
char *str = 0;
void *generic = 0;
```
#### 3. Using (void*)0 cast
```c
int *ptr = (void*)0;
char *str = (void*)0;
```
#### 4. Using typed cast with 0
```c
int *ptr = (int*)0;
char *str = (char*)0;
```
#### 5. Implicit initialization to zero
```c
// Global and static variables are automatically initialized to 0/NULL
static int *global_ptr;   // Automatically NULL
int *static_ptr;          // If declared at file scope, automatically NULL

// In functions with explicit zero initialization
int *ptr = {0};           // Less common syntax
```
#### 6. Using \0 character (technically works but unusual)
```c
int *ptr = '\0';       // Works because '\0' is 0, but not recommended
```
#### 7. Using nullptr
```c
int *ptr = nullptr;
```
### Why null pointers?
A good practice is to use safety null pointer check.
Safety null pointer check is when we are declaring a non-initialized pointer to be used after a while, we set it to null, and every time we are accessing this pointer (read/write) we check if that pointer is not equal to null.
```c
#include <stdio.h>

int main() {
	int *p=NULL;
	if(p!=NULL) {
		printf("%i", p);
	} else
        printf("The Pointer is NULL\n");
}
```
This demonstrates the safety null pointer check principle: always verify a pointer is not NULL before attempting to dereference it.
So, I can avoid segmentation fault.
# Call by reference
Look at this code:
```c
#include <stdio.h>

void swap(int num1, int num2);

int main() {
	int x=7, y=2;
	swap(x,y);
	printf("%i\n", x);
	printf("%i\n", y);
}

void swap(int num1, int num2) {
	int temp=y;
	x=y;
	y=temp;
}
```
Output:
```
7
2
```
This is because the function is called by value, which means that the function makes another variables that have a function scope only. So, after returning the function swapped only `num1`and `num2` variables, not the actual `x`and `y` .

To solve this problem we deal with the calling by reference:
```c
#include <stdio.h>

void swap(int *num1, int *num2);

int main() {
	int x=7, y=2;
    swap(&x,&y);          // passing the address as a pointer.
	printf("%i\n", x);
	printf("%i\n", y);
}

void swap(int *num1, int *num2) {    // recieving the vars as pointers.
	int temp=*num1;
	*num1=*num2;
	*num2=temp;
}
```
Output:
```
2
7
```
****
So, the `printf("%i", x);` function takes a copy from the variable as I only read it, I do not want to change anything in it.
While, the `scanf("%i", y);` function modifies the variable (the memory address) itself as it overwrites that memory address.
# Const Pointers
You can define a constant pointer that can hold only one address in the whole program time.
```c
int *const ptr = &x;
```
You can not change the pointer itself, but you can change the pointed value.
```c
int *const ptr = &x;
ptr = &y; // not allowed
ptr++;    // not allowed
*ptr = 19; // allowed
(*ptr)++;  // allowed 
```
 Notice the difference:
 ```c
 int *const ptr;   // The pointer itself is constant to a fixed address
 const int *ptr;   // The pointed var itself is constant
 int const *ptr;   // The pointed var itself is constant
 ```
 The pointer to a constant value is widely used with strings functions like copying them.
 You can define a const pointer to a const value:
 ```c
 const int *const ptr = &x;
 ```
# Dangling Pointer
To understand dangling pointers, we need to understand returning address functions.
```c
int *func(void) {
	int x = 50;
	// some code
	return &x;
}
```
This function is a function that returns a pointer to the address of the value.
You can use it inside the main and store it in a pointer:
```c
#include <stdio.h>

int *func(void);

int main() {
	int *ptr;
	ptr = func();
}

int *func(void) {
	int x = 50;        // will be de-allocated
	// some code 
	return &x;
}
```
That code will compile normally, there is no syntax error, but there is a small problem which is dangling pointer.
This code has a logical error, which is returning an address of a deleted variable (or we can say de-allocated variable), which means that the line code containing `ptr = func()` has a logical problem which is dangling pointer. The `ptr` is now holding the address of a de-allocated variable.
## So, Dangling Pointers are pointers that points to a de-allocated variable.
To solve this problem we use a different approach, we define the variable which we will return its address with `static` keyword.
If you remember `static` local variables are kept the whole program life-time, it is also stored in `.rodata` not in the `stack`.
So, the code will be like this:
```c
#include <stdio.h>

int *func(void);

int main() {
	int *ptr;
	ptr = func();
}

int *func(void) {
	static int x = 50;   // won't be de-allocated
	// some code
	return &x;
}
```
## Never return a pointer to automatic variables.
# Dereference an address with casting
If you tried to access a written address yourself you will fail.
```c
#include <stdio.h>

int main() {
	int x=65537;                 // noticed its address is 35526262
	printf("%i", *35526262);   
}
```
This won't compile, as you are trying to dereference an `int`, you have to cast into `int pointer` first:
```c
#include <stdio.h>

int main() {
	int x=65537;
	printf("%i", *(int*)35526262);   
}
```
Output:
```
65637        // may differ according to the address on your environment
```
If you tried to mess a little bit with the casting and replaced `int pointer` with a `short`one, you will now access the first two bytes only.
```c
#include <stdio.h>

int main() {
	int x=65537;
	printf("%i", *(short*)35526262);   
}
```
Output:
```
1            // may differ according to the address on your environment
```
# Void Pointer (General Purpose Pointer)
The void pointer is a pointer that can fit for any datatype. The default step value of it is **1 byte**.
Its syntax:
```c
void *ptr;
```
If you are having different variables with different datatypes that you want to point to them, but sequentially not in the same time, instead of declaring more than a pointer with just use the void pointer as it will fit to them all.
But it has a problem, which is casting, every time you are accessing this pointer you need to cast it manually to the appropriate pointer.
```c
void *p;
int x = 9;
p = &x;  
printf("%i\n", *(int *)p); // you can not type printf("%i", *p);
char ch = 100;
p = &ch;            
printf("%c\n", *(char *)p); // you can not type printf("%c", *p);
```
# Pointer to Function
If I have a function that is stored in 8 bytes in the flash, the name of the function is a pointer to the first byte of them. So, you can save a pointer to the name of the function and instead of calling the function with its name, you are calling it using the pointer.
```c
#include <stdio.h>

int sum(int, int);

int main() {
    int (*ptr)(int, int);
    ptr = sum;
    printf("%i\n", ptr(3,5));
}

int sum(int x, int y) {
    return x + y;
}
```
Output:
```c
8
```
So, the pointer here is a pointer to a function that takes two integers and return an integer:
`int (*ptr) (int,int);`
# Pointer to Pointer
What if I want to store the address of a pointer?
I can set a pointer pointing to another pointer.
```c
#include <stdio.h>

int main() {
	int x=50;         
	int *p1=&x;
	int **p2=&p1;
	
	printf("%i\n", *p2);        
	// prints the value of the address it is holding (value of p1) 
	// which is the address of x variable. 
	printf("%i\n", **p2);
	// dereferences its dereference which means it will print the dereference of the address of x. which is the value of x
}
```
Output:
```
-65012060
50
```

```c
int x=70;
int *p1=&x;
int **p2=&p1;

printf("p1\t=\t%i\n", p2);
printf("*p2\t=\t%i\n", *p2);
printf("**p2\t=\t%i\n", **p2);
```
Output:
```
p2      =       6356724    // &p1
*p2     =       6356728    // &x
**p2    =       70         // x
```

Okay can you tell the step of a pointer to pointer is what?
As all pointers have the same size (depending on the system) in the 32-bit system the pointer size is 4 bytes, so the step of a pointer to pointer in a 32-bit system is 4 bytes.
# Changing const pointer
Same as we talked about changing the const local, we can change the const local pointers by pointers to pointers.
```c
#include <stdio.h>

int main() {
	int x=50;
	int *const ptr1=&x;
	int **ptr2=&ptr1;
	printf("%i\n", ptr1);   // prints the address of x (cannot be changed)
	ptr2=&ptr1;
	(*ptr2)++;
	printf("%i\n", ptr1);   // prints the address of x + 4 bytes
}
```
Output:
```
6356728
6356732
```
# Swapping Pointers
Remember the function of swapping we talked about at the calling by reference?
Can we do the same things to pointers?
I have 2 pointers, one holding the address of x, the other holding the value of y. I want to swap them, how can we do that?
```c
#include <stdio.h>

void swap(int **, int **);

int main() {
    int x=50, y=80;
    int *ptr1=&x;
    int *ptr2=&y;
    printf("Before the swap:\n%i, %i\n", *ptr1, *ptr2);
    swap(&ptr1, &ptr2);
    printf("After the swap:\n%i, %i\n", *ptr1, *ptr2);
}

void swap(int **p1, int **p2) {
    int *temp=*p1;
    *p1=*p2;
    *p2=temp;
}
```
Inside the function what is happening?
![pic4_14](pic4_14.png)
#### First we have the first line:
`int *temp=*p1;`
This line is storing the `*p1` dereference of the address p1 holding, which is `100` the address of the x variable.
So, `temp` now contains `100`.
#### After that the second line:
`*p1=*p2;`
Now we are assigning inside the dereference value of the `p1` which is the `ptr1`.
We are changing the address `ptr1` is pointing to (`&x`) to another address which is the address `ptr2` pointing to (`&y`).
So now `ptr1` is pointing to `y` instead of `x`.
#### The final line:
`*p2=temp;`
Now we are changing the value of `ptr2` into the value which is stored in `temp`, so that `ptr2` now is pointing with temp to (`&x`).

A clear overview of what happened:
![pic5_14.png](pic5_14.png)
# Endianness
In 80s, Dahn Cohen a computer scientist published a paper talking about how computers stores variables in memory.
He demonstrated that we have 2 types of storing variables.
## Little endian:
It is the storing of the variables from the least significant byte to its most significant byte.
So, as an example if we have an int value named x having a `0x0A0B0C0D` value, it will start storing it in the memory from the most right byte.
![little endian](pic6_14.png)
**This is widely used in x86 architectures.**
## Big endian:
It is the storing of the variables from the most significant byte to its least significant byte.
So, as an example if we have the same variable we had above, it will start storing it in the memory from the most left byte.
![big endian](pic7_14.png)
**This is widely used in networking.**
****

There is some functions to convert between the big endian and the little endian, they are named NToH (Network to Host) that converts from big endian to little endian, and HToN (Host to Network) that converts from little endian to big endian.

Notice that during dealing with pointers of the same type, the type of endianness will never differ.
But if you are using a smaller pointer this can make some troubles if you don't know the type of your endianness.
# Tricky question
What is the output of this code:
```c
#include <stdio.h>

int main()
{
    short a=512;
    char *p=(char*)&a;
    p[0]=1;
    p[1]=2;
    printf("%d\n", a);
}
```
a) System dependent
b) 513
c) 258
d) Compilation error

The answer is **a) System dependent** as it may differ from big endian environment than a little endian one.
## Big endian environment:
![big endian enviro](pic8_14.png)
## Little endian environment:
![little endian enviro](pic9_14.png)
# Tasks
## Task 1:
Write a code using pointers to check the endianness of your IDE.
My solution:
```c
#include <stdio.h>

int main() {
    const short a=0b0000000100000000;
    const char *p=(const char*)&a;
    if(*p == 0 && p[1] == 1)
        printf("Your IDE is operating on Little endian");
    else
        printf("Your IDE is operating on Big endian");
}
```
## Task 2:
What is the output of this code:
```c
#include <stdio.h>

int f(int x, int *py, int **ppz)
{
    int y, z;
    **ppz += 1;
    z = **ppz;
    *py += 2;
    y = *py;
    x += 3;
    return x + y + z;
}

void main()
{
    int c, *b, **a;
    c = 4, b = &c, a = &b;
    printf("%d", f(c, b, a));
}
```
Answer is:
```
19
```

Explanation in an abstract way:
![Abstract Explanation](pic10_14.png)\
